[toc]

[原文](https://community.mellanox.com/s/article/howto-prevent-infiniband-credit-loops)

InfiniBand网络的设计原则是成为一个无损网络。当网络出现拥塞时，InfiniBand的标准做法是不发送数据，除非接收方有空间容纳它，而不是丢弃数据包来处理它。

这篇文章讨论了**InfiniBand (IB)信用回环**以及拓扑和路由算法选择在**防止信用回环**中的作用。

## 理解信用回环

### 链路级别的信用（Link-Level Credit）

每个HCA端口和Switch端口都实现了链路上发送者和接收者之间的信任机制。它适用于**所有链路方向**，以及物理链路两端由硬件实现的每个**虚拟通道(VL)**。

多个信用“状态机”和单独的VL缓冲区有助于:

* 一个VL上的通信不会干扰另一个VL上的通信
* 在同一个VL内，一个方向上的通信不会干扰相反方向的通信

当一个物理链路处于活动状态时，每个VL的每个方向上的发送方和接收方都在不断地通信，因此发送方知道在接收方为该VL保留了多少缓冲空间。可用空间的数量用“信用(Credits)”表示，其中一个信用值表示一定数量的字节。如果接收VL缓冲区满了，发送方将停止发送数据，直到有更多的空间(信用)可用。当接收方报告没有可用信用额度时，它就开始对发送方施加“反压力”。

对于HCA端口，如果IB应用程序没有足够快地消耗数据，信用机制允许相邻的交换机停止向服务器发送数据。当代码效率低下、内核panic或主机cpu过载时，就会发生这种情况。对于来自HCA端口的出站流量，信用机制允许数据留在主机内存中，直到相邻的交换机为其准备好为止。

例如，在子网中，如果交换机S有一个端口 P ，是接收来自相邻交换机 N 虚拟通道 X 的数据，数据包将被放置在虚拟通道 X 的传输队列中，传输到端口P。如果积累足够的数据包，交换机耗尽了虚拟通道 X 接收缓冲区，将报告没有额度可供虚拟通道 X 使用，从而在 虚拟通道X 的所有端口上施加背压。通过这种方式，子网中一个端口的背压可以在子网中传播——**在必要的情况下，会从目的地HCA一路传播到源HCA**。

如果背压持续存在，则在传输队列中等待时间过长的数据包将超时并被丢弃。这个队列头(HOQ)超时是通过子网管理器指定的。运行在可靠传输服务上的流量由源hca自动重传。这个超时过程是为了防止子网死锁而设计的。这也是唯一故意丢弃IB数据包的情况。

### 信用回环（Credit Loops）

与许多其他网络一样，InfiniBand不喜欢回环。具体来说，它不喜欢链接背压可能导致死锁的逻辑循环。这被称为Credit Loops（信用回环）。尽管HOQ计时器会定期清除这样的死锁，但性能会受到影响。信用回环仅代表潜在的死锁，这取决于回环中每个链路上的流量。然而，在InfiniBand的高速度以及特定的传输模式下，这样的死锁可能会发生得非常快。

下图展示了一个非常简单的信用回环。

![img](.assets/Credit Loops/rtaImage-1620806419237)  

**在这个例子中:**

* 4个Switch asic采用环形拓扑连接。
* 主机适配器(HCA)将服务器(节点)连接到每个交换机，交换机4上有一个附加的HCA。

其他的假设:

* 通过Minhop路由算法设置路由。

* 所有流量都发送到同一虚拟通道上。

**传输模式:**

- Node A -> node C.
- Node B -> node D.
- Node C -> node A.
- Node E -> node B.

在这种传输模式下，每个IB线缆运载两个数据流。

如果由于某些原因，节点D的应用程序无法接受节点B的数据包:

* HCA D 对 交换机4 施加背压
* 交换机4从交换机3向其链路施加背压
* 交换机3从交换机2对其链路施加背压，也对HCA C施加压力
* 交换机2对HCA B施加背压，但是由于A->B->C的数据流，也从交换机1对其链路施加回压
* 交换机1从交换机4对其链路施加压力，也对 HCA D 和 E 施加压力

此时，没有一个HCA可以发送数据。如果节点D不能及时恢复，交换机的Head of Queue定时器将失效，所有报文将被丢弃。使用可靠传输服务的数据包将被重试。总的来说，延迟和带宽都会受到影响。

以下是IB信用回环的必要成分:

* 一个物理链接上的回环。
* 一组节点到节点的通信路径(在同一个VL上)，其路径之间存在循环依赖关系。在前面的图中，子网管理器设置的四个路径具有相互依赖关系，如果一个接收端停止，并且所有路径上的流量都足够高的情况下，则可能会产生死锁。

> 注意:构成循环依赖关系的每个路径将至少包含三个开关。前面的图显示了四个路径，每个路径包括三个开关。

### IB 子网中的信用回环

除了最小的IB子网外，所有子网都有物理回路。对于环面(torus)、网格(mesh)和超立方体(hypercube)等拓扑结构来说，这一点更为明显，对于标准的“胖树”同样如此。从技术上讲，树状拓扑结构没有循环，但IB“树”有许多物理循环，除非它们是只有一个L2(脊柱/核心)交换机的2层结构(又名Clos-3)，例如真正的树状结构。

下图显示了一个小Clos-3子网。它包含多个物理的4开关回路，类似于前面的图表。其中一个循环突出显示。我们的目标是防止实体循环变成信用回环。

![img](.assets/Credit Loops/rtaImage-1620806442246)  

#### 防止信用回环

虽然含有信用回环的轻负荷IB子网可以长时间运行而没有问题，但最佳实践是在子网设计中消除信用回环。

消除信用回环最常见的技巧包括:

* 良好的物理拓扑，包括良好的节点布局

* 更好的路由算法

* 多个虚拟通道

其中一些方法会影响系统性能或增加开销成本。

### 通过物理拓扑消除环路

前面的简单循环例子可以通过几种方式消除信用回环。四种方式如下图所示:

![img](.assets/Credit Loops/rtaImage-1620806461444) 

* a: 消除了交换机间的连接，比如位于交换机S2和S3之间的连接，因为它打破了物理循环，所以不可能有信用循环。
* b: 在相反的switch之间添加一条电缆，例如在switch S2和S4之间，这实际上会创建更多的物理循环。在这种情况下，它创建了两个新的3-Switch循环。然而，因为所有IB路由算法都被设计为使用“最短路径优先”，这个fabric中的所有流量流都是“点对点”，只涉及两个交换机。不会有数据流经过第三个Switch。即使Switch耗尽了VL缓冲区空间，信用回压也不会传播并形成循环死锁。

* c: 从一个交换机(本例中为S2)中删除所有节点将消除通过交换机S1和S3的3-Switch路径。节点B从S2移动到S3。在本设计中，3-Switch数据通过S2(本例中为A <-> B或C)和S4 (A <-> B或C的备选路径)。但是，由于最短路径优先路由，子网管理器不提供通过S1或S3的3-Switch路径(或4-Switch路径)。
* d: 在这种情况下，物理拓扑没有改变，但是使用Up/Down路由代替Minhop路由。一个Switch(在本例中为S1)被定义为根交换机。使用Up/Down算法可以通过禁止路径S2->S3->S4和S4->S3->S2来打破逻辑循环。更多信息请参考了解上行/下行InfiniBand路由算法的文章。

在上述这些情况下，可以通过以下方式防止信用回环:

* 从物理结构上消除了循环
* 在有三个或更多开关的足够路径后，这样就不能形成依赖循环

此方法的一个实际示例适用于2层(Clos-3) 子网，其中的最佳实践是不将服务器附加到L2交换机。下面是一个带有信用循环的Clos-3示例。注意，删除节点X和Y会打破所有循环:

![img](.assets/Credit Loops/rtaImage-1620806479796)  

注意:Clos-3 fabric中L2的IB网关是一个例外，因为它们交换的流量太小，无法完成一个回压回路。其他节点之间不交换太多数据的也可以放在L2，尽管它们与L1节点的连接可能是高带宽的。请参见“VPI网关注意事项”。

### 利用路由算法消除回环

有三种常用的IB路由算法可以使用:

- Minimum hop (minhop)
- Up/down (updn)
- Fat tree (ftree)

> 其它算法并不常见，不在本文讨论范围

Minhop并不能消除回环。与所有IB路由引擎一样，它从最短路径生成树开始，并尝试在可用物理链路上静态地(在每个节点对之间)平衡所有可能的逻辑路径。它完全连接所有可到达的节点。因此，Minhop是一个很好的默认算法，如果物理网络首先被启动，正在被修改，或者由于链路或交换机故障而降级。对于设计合理的Clos-3网络(交换机asic的两层)，其中信用循环已经被物理连接消除，Minhop对于生产集群是一个可行而简单的选择，但对于Clos-3以外的任何东西都不是。

Up/Down算法是大型集群的常见选择，原因如下:

* 它保证不存在信贷循环。
* 对于非经典的“胖树”拓扑，它是相当宽容的，例如在组合以前是独立的IB集群时。
* 建议使用路由链特性为每个组合的IB集群提供最优路由。

如果你使用Up/Down算法，你需要使用一个小的SM配置文本文件来定义子网的“根”交换机。因为该算法不允许某些逻辑路径来打破循环，所以某些节点可能无法“ping”彼此，除非遵循Up/Down算法的最佳实践。

胖树路由是Up/Down路由的近亲。与Up/Down算法一样，它接受根交换机列表并保证无环逻辑拓扑。然而，胖树只能选择对称(纯)和近似对称的胖树，所以对于更有创意的树状织物来说，它是无用的。通过关注几乎纯胖树，胖树算法可以做更多的逻辑路径的全局平衡。因此，它的路由比Up/Down提供的更有效率，因为Up/Down有更多的本地平衡。

注意:Up/Down和Fat Tree算法都尝试在没有根交换机列表的情况下操作。不建议在没有根交换机列表的情况下使用UP/Down，不能保证正确的根交换机自动检测。胖树只能在纯理论的胖树拓扑中运行w/o根交换机列表。否则它将会失败。当胖树算法明确地知道根时，它减少了对它可以路由到的拓扑的限制。

### 其他消环方法

其他的技术不在本文的讨论范围之内。注意，用于Hypercube和Enhanced Hypercube的DOR算法以及用于2d和3D网格和环面拓扑的Torus2QoS算法都是无积分环的路由引擎

