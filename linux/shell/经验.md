

## 脚本单例

### 方案1

说到锁文件，这里就不得不提flock命令了。没有前面的一些巧妙处理，我们很多时候会很难删除原先创建的锁文件，比如：

- 脚本被意外中断，没来得及执行删除
- 多个脚本产生竞争，导致判断异常，比如前面有一个脚本运行，判断没有锁文件，下一步准备创建，但是另外一个脚本又先创建了，就会导致异常了。

因此我们可以考虑使用flock：

```sh
#!/usr/bin/env bash
#来源：公众号编程珠玑
LOCK_FILE=/tmp/test.lock
exec 99>"$LOCK_FILE"
flock -n 99
if [ "$?" != 0 ]; then
    echo "$0 already running"
    exit 1
fi
#脚本要做的其他事情
sleep 1024
```

解释一下：

- `exec 99>"$LOCK_FILE"` 表示创建文件描述符99，指向锁文件，为何是99?110其实也是可以的，只是为了和当前脚本可能打开的文件描述符冲突（例如和0,1,2冲突）。
- `flock -n 99`  尝试对该文件描述符加锁，由操作系统保证原子性
- 一旦flock失败了，我们这里可以退出
- 而即使锁定了，脚本退出后，也会自动释放

因此这里避免了锁没有释放的情况。

### 方案2

```sh
#!/usr/bin/env bash

[ "${FLOCKER}" != "$0" ] && exec env FLOCKER="$0" flock -en  "$0"  "$0"  "$@" || :

#脚本要做的其他事情
sleep 1024
```

解释一下：

- 如果`${FLOCKER}`环境变量没有设置，则尝试将脚本本身加锁，如果加锁成功，则运行当前脚本，（并且带上原有的参数），否则的话静默退出。
